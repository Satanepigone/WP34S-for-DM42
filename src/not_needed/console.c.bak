/* This file is part of 34S.
 * 
 * 34S is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * 34S is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with 34S.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 *  This is the console emulator part
 */
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>

#ifdef DM42
#include "dmcp.h"
#endif

#define DM42SAFE

#include "keys.h"
#include "display.h"
#include "lcd.h"
#include "int.h"
#include "consts.h"
#include "storage.h"
#include "catalogues.h"
#undef DM42SAFE

#ifndef DM42

#define CH_QUIT		'Q'
#define CH_TRACE	'T'
#define CH_FLAGS	'F'
#define CH_ICOUNT	'C'
#define CH_REFRESH	12	/* ^L */
#define CH_COPY		'X'
#define CH_PASTE	'V'

unsigned long long int instruction_count = 0;
int view_instruction_counter = 0;
#endif


#ifdef DM42

const uint8_t mid_menu[] = {
    MI_SYSTEM_ENTER,
    0 }; // Terminator

const smenu_t MID_MENU = { "System!",  mid_menu,   NULL, NULL };
/*
 *  PC keys to calculator keys
 */
static int remap(const int c) {
  switch (c) {
  case KEY_F1:	return K_F;
  case KEY_F2:	return K_G;
  case KEY_F3:	return K_H;
  case KEY_F4:	return K05; //CPX
  case KEY_F6:
    SET_ST(STAT_MENU);
    handle_menu(&MID_MENU, MENU_RESET, 0); // App menu
    CLR_ST(STAT_MENU);
    return K_UNKNOWN;

  case KEY_SIGMA:	return K00;
  case KEY_INV:	return K01;
  case KEY_SQRT:	return K02;
  case KEY_LOG:	return K03;
  case KEY_LN:	return K04;

  case KEY_STO:	return K10;
  case KEY_RCL:	return K11;
  case KEY_RDN:	return K12;
  case KEY_SIN:	return K_F;
  case KEY_COS:	return K_G;
  case KEY_TAN:	return K_H;

  case KEY_ENTER:	return K20;
  case KEY_SWAP:	return K21;
  case KEY_CHS:	return K22;
  case KEY_E:	return K23;
  case KEY_BSP:	return K24;	// Backspace

  case KEY_XEQ:	return K30;
  case KEY_7:	return K31;
  case KEY_8:	return K32;
  case KEY_9:	return K33;
  case KEY_DIV:	return K34;

  case KEY_UP:	return K40;
  case KEY_4:	return K41;
  case KEY_5:	return K42;
  case KEY_6:	return K43;
  case KEY_MUL:	return K44;

  case KEY_DOWN:	return K50;
  case KEY_1:	return K51;
  case KEY_2:	return K52;
  case KEY_3:	return K53;
  case KEY_SUB:	return K54;

  case KEY_EXIT:	return K60;	// ON
  case KEY_0:	return K61;
  case KEY_DOT:	return K62;
  case KEY_RUN:	return K63;
  case KEY_ADD:	return K64;

  case K_HEARTBEAT: return K_HEARTBEAT;
  case 0: return K_RELEASE;
  }
  return K_UNKNOWN;
}
#else
/*
 *  PC keys to calculator keys
 */
static int remap(const int c) {
	switch (c) {
	case 'F':	return K_F;
	case 'G':	return K_G;
	case 'H':	return K_H;

	case 'q':	return K00;
	case 'w':	return K01;
	case 'B':	return K01;
	case 'e':	return K02;
	case 'C':	return K02;
	case 'r':	return K03;
	case 'D':	return K03;
	case 't':	return K04;
	case 'y':	return K05;

	case 'a':	return K10;
	case 's':	return K11;
	case 'd':	return K12;
	case 'f':	return K_F;
	case 'g':	return K_G;
	case 'h':	return K_H;

	case 'z':	return K20;
	case 'x':	return K20;
	case '\r':	return K20;
	case '\n':	return K20;
	case 'c':	return K21;
	case 'v':	return K22;
	case 'b':	return K23;
	case 'n':	return K24;	// Backspace
	case 127:	return K24;
	case 8:		return K24;

	case 'u':	return K30;
	case '7':	return K31;
	case '8':	return K32;
	case '9':	return K33;
	case '/':	return K34;

	case 'j':	return K40;
	case '4':	return K41;
	case '5':	return K42;
	case '6':	return K43;
	case '*':	return K44;

	case 'm':	return K50;
	case '1':	return K51;
	case '2':	return K52;
	case '3':	return K53;
	case '-':	return K54;

	case ' ':	return K60;	// ON
	case '0':	return K61;
	case '.':	return K62;
	case ',':	return K63;
	case '+':	return K64;
	}
	return K_UNKNOWN;
}
#endif

#include "pretty.c"


#include "xrom.h"
#include "xrom_labels.h"
static const struct {
	unsigned int address;
	const char *const name;
} xrom_entry_points[] = {
#define XE(l)		{ XROM_ ## l, # l }
	XE(2DERIV),			XE(F_DENANY),			XE(QF_WEIB),
	XE(AGM),			XE(F_DENFAC),			XE(QUAD),
	XE(Bn),				XE(F_DENFIX),			XE(RADIANS),
	XE(Bn_star),			XE(GRADIANS),			XE(RADIX_COM),
	XE(CDFU_BINOMIAL),		XE(HR12),			XE(RADIX_DOT),
	XE(CDFU_CAUCHY),		XE(HR24),			XE(SEPOFF),
	XE(CDFU_CHI2),			XE(HermiteH),			XE(SEPON),
	XE(CDFU_EXPON),			XE(HermiteHe),			XE(SETCHN),
	XE(CDFU_F),			XE(IDIV),			XE(SETEUR),
	XE(CDFU_GEOM),			XE(IM_LZOFF),			XE(SETIND),
	XE(CDFU_LOGIT),			XE(IM_LZON),			XE(SETJAP),
	XE(CDFU_LOGNORMAL),		XE(INTEGRATE),			XE(SETUK),
	XE(CDFU_NORMAL),		XE(ISGN_1C),			XE(SETUSA),
	XE(CDFU_POIS2),			XE(ISGN_2C),			XE(SIGMA),
	XE(CDFU_POISSON),		XE(ISGN_SM),			XE(SIGN),
	XE(CDFU_Q),			XE(ISGN_UN),			XE(SOLVE),
	XE(CDFU_T),			XE(JG1582),			XE(STACK_4_LEVEL),
	XE(CDFU_WEIB),			XE(JG1752),			XE(STACK_8_LEVEL),
	XE(CDF_BINOMIAL),		XE(LaguerreLn),			XE(START),
	XE(CDF_CAUCHY),			XE(LaguerreLnA),		XE(W0),
	XE(CDF_CHI2),			XE(LegendrePn),			XE(W1),
	XE(CDF_EXPON),			XE(MARGIN),			XE(WHO),
	XE(CDF_F),			XE(NEXTPRIME),			XE(W_INVERSE),
	XE(CDF_GEOM),			XE(PARL),			XE(ZETA),
	XE(CDF_LOGIT),			XE(PDF_BINOMIAL),		XE(beta),
	XE(CDF_LOGNORMAL),		XE(PDF_CAUCHY),			XE(cpx_ACOS),
	XE(CDF_NORMAL),			XE(PDF_CHI2),			XE(cpx_ACOSH),
	XE(CDF_POIS2),			XE(PDF_EXPON),			XE(cpx_ASIN),
	XE(CDF_POISSON),		XE(PDF_F),			XE(cpx_ASINH),
	XE(CDF_Q),			XE(PDF_GEOM),			XE(cpx_ATAN),
	XE(CDF_T),			XE(PDF_LOGIT),			XE(cpx_ATANH),
	XE(CDF_WEIB),			XE(PDF_LOGNORMAL),		XE(cpx_CONJ),
	XE(CPX_AGM),			XE(PDF_NORMAL),			XE(cpx_CROSS),
	XE(CPX_COMB),			XE(PDF_POIS2),			XE(cpx_DOT),
	XE(CPX_FIB),			XE(PDF_POISSON),		XE(cpx_EXPM1),
	XE(CPX_I),			XE(PDF_Q),			XE(cpx_FACT),
	XE(CPX_PARL),			XE(PDF_T),			XE(cpx_FRAC),
	XE(CPX_PERM),			XE(PDF_WEIB),			XE(cpx_IDIV),
	XE(CPX_W0),			XE(PERCENT),			XE(cpx_LN1P),
	XE(CPX_W_INVERSE),		XE(PERCHG),			XE(cpx_LOG10),
	XE(ChebychevTn),		XE(PERMARGIN),			XE(cpx_LOG2),
	XE(ChebychevUn),		XE(PERMMR),			XE(cpx_LOGXY),
	XE(DATE_ADD),			XE(PERTOT),			XE(cpx_POW10),
	XE(DATE_DELTA),			XE(PRODUCT),			XE(cpx_POW2),
	XE(DATE_TO),			XE(QF_BINOMIAL),		XE(cpx_ROUND),
	XE(DEGREES),			XE(QF_CAUCHY),			XE(cpx_SIGN),
	XE(DERIV),			XE(QF_CHI2),			XE(cpx_TRUNC),
	XE(D_DMY),			XE(QF_EXPON),			XE(cpx_beta),
	XE(D_MDY),			XE(QF_F),			XE(cpx_gd),
	XE(D_YMD),			XE(QF_GEOM),			XE(cpx_inv_gd),
	XE(E3OFF),			XE(QF_LOGIT),			XE(cpx_lnbeta),
	XE(E3ON),			XE(QF_LOGNORMAL),		XE(cpx_x2),
	XE(ERF),			XE(QF_NORMAL),			XE(cpx_x3),
	XE(ERFC),			XE(QF_POIS2),			XE(gd),
	XE(FIB),			XE(QF_POISSON),			XE(int_ULP),
	XE(FIXENG),			XE(QF_Q),			XE(inv_gd),
	XE(FIXSCI),			XE(QF_T),
#undef XE
};
#define num_xrom_entry_points	(sizeof(xrom_entry_points) / sizeof(*xrom_entry_points))
	
static const struct {
	opcode op;
	const char *const name;
} xrom_labels[] = {
#define X(op, n, s)	{ RARG(RARG_ ## op, (n) & RARG_MASK), s},
#define XE(n, s)	X(ERROR, n, "Error: " # s)	X(MESSAGE, n, "Message: " # s)
	XE(ERR_DOMAIN, "Domain Error")
	XE(ERR_BAD_DATE, "Bad Date Error")
	XE(ERR_PROG_BAD, "Undefined Op-code")
	XE(ERR_INFINITY, "+infinity")
	XE(ERR_MINFINITY, "-infinity")
	XE(ERR_NO_LBL, "no such label")
	XE(ERR_ILLEGAL, "Illegal operation")
	XE(ERR_RANGE, "out of range error")
	XE(ERR_DIGIT, "bad digit error")
	XE(ERR_TOO_LONG, "too long error")
	XE(ERR_RAM_FULL, "RTN stack full")
	XE(ERR_STK_CLASH, "stack clash")
	XE(ERR_BAD_MODE, "bad mode error")
	XE(ERR_INT_SIZE, "word size too small")
	XE(ERR_MORE_POINTS, "more data points required")
	XE(ERR_BAD_PARAM, "invalid parameter")
	XE(ERR_IO, "input / output problem")
	XE(ERR_INVALID, "invalid data")
	XE(ERR_READ_ONLY, "write protected")
	XE(ERR_SOLVE, "solve failed")
	XE(ERR_MATRIX_DIM, "matrix dimension mismatch")
	XE(ERR_SINGULAR, "matrix singular")
	XE(ERR_FLASH_FULL, "flash is full")
	XE(MSG_INTEGRATE, "integration progress")
#undef XE
#undef X
};
#define num_xrom_labels		(sizeof(xrom_labels) / sizeof(*xrom_labels))


void shutdown( void )
{
#ifndef DM42
  checksum_all();
  setuptty( 1 );
  save_statefile( NULL );
  exit( 0 );
#else
  save_statefile();
  SET_ST(STAT_PGM_END);
#endif
}


/*
 *  Dummies
 */
int is_key_pressed(void) 
{
#ifdef DM42
  return !key_empty();
#else
  return 0;
#endif
}

int get_key(void)
{
  #ifdef DM42
  return key_pop();
  #else
  return 0;
  #endif
}

int put_key( int k )
{
  #ifdef DM42
  return key_push(k);
  #else
  return k;
  #endif
}

enum shifts shift_down(void)
{
	return SHIFT_N;
}

#ifndef DM42   // No serial operations for DM42
#ifndef WIN32  // Windows uses winserial.c
/*
 *  Open a COM port for transmission
 */
int open_port( int baud, int bits, int parity, int stopbits )
{
	return 0;
}


/*
 *  Close the COM port after transmission is complete
 */
extern void close_port( void )
{
}


/*
 *  Output a single byte to the serial
 */
void put_byte( unsigned char byte )
{
	report_err(ERR_PROG_BAD);
}


/*
 *  Force buffer flush
 */
void flush_comm( void )
{
}

#endif
#endif


/*
 *  Main loop
 */
#ifdef DM42
void start_key_timer (void);
int keyticks (void);

static int start_ticks;

void start_key_timer() {
    start_ticks = get_rtc_ticks();
}

int keyticks () {
  int i;
  i = (get_rtc_ticks() - start_ticks)*10;
  return i >> 8;
}

int is_paused () {
  return sys_timer_active(1);
}

void start_pause (int i) {
  if ( i >= 0 ) {
    Pause = i;
  }
  return;
}
    
/* void start_pause (int i) { // i>0 - time in 0.1s; i=0:timer stopped;i<0 */
/*   if (i>100) i = 100; // no more than 10s */
/*   if (i>0) { */
/*     sys_timer_start(1, 100*i);  // Timer 1: use for the pause */
/*   } */
/*   else { */
/*     sys_timer_disable(1); // disables timer */

/*   } */
/*   //  else { // i<0 */
/*   //  return sys_timer_timeout(1); // returns 1 if timer expired */
/*   // } */
/* } */
  
char spaces[22] = "                     ";	//21 spaces.
char print_string[22];
int n_p = 0;

void init_graphics() {
  lcd_switchFont(fReg,3); //Font number 3
  fReg->newln = 0;//no newline after printing
  fReg->fixed = 1;//fixed width characters
  strcpy (print_string,spaces);
  lcd_clear_buf();//clear buffer
  lcd_refresh();
}

void moveto(int line, int x) {//These are line number and character positions
  lcd_setLine(fReg, line-1); //line 0 is the top line
  lcd_setXY(fReg, 20 + (fReg->f)->width*(x-1), fReg->y);
}

//print_debug(is_dot(RPN) ? 'X' : 'x');

//void print_debug (char i) {
//  if (n_p < 21) {
//    print_string[n_p] = i;
//    n_p++;
//  }
//}

void print_debug (int i, int j) {
  strcpy( print_string, spaces );
  sprintf ( print_string, "Debug: %4i,%4i", i, j);
  moveto (3, 1);
  lcd_print (fReg , (const char*) print_string );
  lcd_refresh();
  /* wait_for_key_press(); */
  key_pop_all();
  while ((key_pop()<=0) || (key_pop()==K_HEARTBEAT));;
  key_pop_all();
  strcpy( print_string, spaces );
  moveto (3, 1);
  lcd_print (fReg , (const char*) print_string );
  lcd_refresh();
  while (key_empty()<=0);; // wait for release
  key_pop_all();
}


void program_main(){
  int c;

  init_graphics();
  xeq_init_contexts();
  init_34s();
  State2.flags = 1;
  load_statefile();
  display();
  lcd_refresh();
  JustDisplayed = 0;
  /*
    Returns a positive integer when a key is pressed. Doesn't return until a key is pressed.
    Sleeps peacefully while waiting for a key.
    Handles (in principle!) turning off and on.
    =================
    Main event loop
    =================

    Status flags:
    ST(STAT_PGM_END)   - program should turn off state (set by auto off timer)
    ST(STAT_SUSPENDED) - Program ready for off and doesn't need to be woken-up again
    ST(STAT_OFF)       - Program in off state (only [EXIT] key can wake)
    ST(STAT_RUNNING)   - OS doesn't sleep in this mode
  */
  for(;;) {

    if ( ST(STAT_PGM_END) && ST(STAT_SUSPENDED) ) // In off mode and suspended
      {
	CLR_ST(STAT_RUNNING);
	sys_sleep();
      }
    else if (!ST(STAT_PGM_END) && key_empty()) // Go to sleep if no keys available
    {
      CLR_ST(STAT_RUNNING);
      sys_timer_start(0, 100);  // Timer 0: wake up for heartbeat 
      sys_sleep();
      if (sys_timer_timeout(0)) { // If timer has completed...
	key_push (K_HEARTBEAT);
	if (Pause > 0) Pause--;
      }
      sys_timer_disable(0); // stop timer
    }
    
    // Wakeup in off state or going to sleep
    if (ST(STAT_PGM_END) || ST(STAT_SUSPENDED) ) {
      if (!ST(STAT_SUSPENDED)) {
        // Going to off mode
        lcd_set_buf_cleared(0); // Mark no buffer change region
        draw_power_off_image(1);

        LCD_power_off(0);
        SET_ST(STAT_SUSPENDED);
        SET_ST(STAT_OFF);
      }
      // Already in OFF -> just continue to sleep above
      continue; // note - this skips the rest of the loop and goes back to the beginning,
      // thus reaching the sleep()
    }

    // Well, we are woken-up
    SET_ST(STAT_RUNNING);

    // Clear suspended state, because now we are definitely reached the active state
    CLR_ST(STAT_SUSPENDED);

    // Get up from OFF state
    if ( ST(STAT_OFF) ) {
      LCD_power_on();
      rtc_wakeup_delay(); // Ensure that RTC readings after power off will be OK

      CLR_ST(STAT_OFF);

      if ( !lcd_get_buf_cleared() )
        lcd_forced_refresh(); // Just redraw from LCD buffer
    }

    // Key is ready -> clear auto off timer
    //    if ( !key_empty() )
    //  reset_auto_off(); - moved as key here might be heartbeat
    // Fetch the key
    //  < 0 -> No key event
    //  > 0 -> Key pressed
    // == 0 -> Key released
    c = key_pop();
    if ( (c != K_HEARTBEAT) && (c > 0) ) {
      reset_auto_off();
      start_key_timer();
    }
    if (c >= 0) {
      c = remap(c);
      process_keycode(c);
    }
  }
  return;
}
#else
int main(int argc, char *argv[]) {
	int c, n = 0;
	int warm = 0;

	xeq_init_contexts();
#ifndef DM42
	load_statefile( NULL );
#endif      
 skipargs:
	if (!warm)
		init_34s();
	State2.flags = 1;
	if (setuptty(0) == 0) {
		display();
		JustDisplayed = 0;
		while ((c = GETCHAR()) != GETCHAR_ERR && c != CH_QUIT) {
			  c=remap(c);
			if(c != K_UNKNOWN) {
			  process_keycode(c);
			  process_keycode(K_RELEASE);
			}
	}
		setuptty(1);
	}
	shutdown();
	return 0;
}
#endif
