compile_consts.c, compile_cats.c: these are not part of the main code.
xrom_targets.c - just a variable declaration - perhaps auto-generated?
xrom.c - lots of hex addresses - this must be auto-generated too.

console.c - most obviously, this translates keys. I'm a little
confused - it is probably only compiled when we are aiming for the
console version (hence the name). So what's in it must be duplicated
elsewhere. 

commands.c - incomprehensible, but probably straight C code.

alpha.c - deals with the alpha register. No platform-specific code.

charmap.c - automatically generated.

complex.c - just code.

consts.c - automatically generated.

create_revision - probably not interesting.

data.c - only used in IOS. Don't understand.

date.c - just code

decn.c - just code

display.c - lots of good stuff in here, but it will probably work out fine.

font.c - should be fine - automatically generated.

genchars7.c - generates characters; run separately.

genfont.c - generates bitmapped fonts; run separately.

int.c - just code.

keys.c - looks complicated; it might work out ok!

lcd.c - appears to be pretty much all USECURSES and / or CONSOLE.

lcdgen.c - separate program; appears to deal directly with the real hardware.

matrix.c - for masochists only.

post_process.c - appears to help generate the realbuild output files.

pretty.c - probably not relevant; I think it's used to format dumps.

printer.c - can be ignored at first - requires INFRARED to be defined.

prt.c - can also be ignored - probably only required for dumps.

serial.c - I don't feel the need for this, but I'm not sure where it
fits in. Commands defined in it appear in commands.c, so if I take it
out that would have to be edited. 

stats.c - code.

stopwatch.c - can be ignored.

storage.c - probably ok; it works for the emulators, so it should work
for me. I'll need to sort out the file writing stuff. 

string.c - c stuff; don't really understand it, but I guess it's ok.

translate.c - autogenerated.

winserial.c - can ignore this.

xeq.c - big important file but shouldn't pose problems.

Problem files:

console.c
lcd.c
commands.c (remove any that aren't being included, e.g., serial ones)

Looks easy! Maybe.

Files that can go completely:
data.c? GONE but data.h is needed.

lcdgen.c? lcdmap.h needs this; removed both? OK

post_process.c? GONE

printer.c - used by both infrared and by serial. Printer.h is input
automatically, can be removed but there isn't a simple thing to define
/ undefine 

serial.c and winserial.c, once commands.c has been edited
Note: as well as commands.c, commands must be removed from xeq.h and
from compile_cats.c 

pretty.c and prt.c once console.c has been edited.
Actually, pretty is used by some of the programs that prepare files
(e.g., catalogues) to be used by the main program. I need to separate
out the two parts - these earlier programs don't want to be
cross-compiled! 

stopwatch.c GONE but had to change in features.h and xeq.c as well as
the makefile 

Once I've got this working for the console version, I need to turn to
the problem of cross-compiling. 
To start with I can assign the keys blindly.
The display stuff can initially be very basic as well.

Let's look at the two parts. Things that get generated are:
* all the consts - these live in a subdirectory of Linux64. They end
up producing consts.c and consts.h, and user_consts.h. libconsts.a
also gets generated; probably not needed? Well, it ends up in the
object file directory. 
Note that .a files seem to be a directory listing of object files! No
- that's how less shows them. They contain sets of object files - they
are static libraries. So these will have to be cross-compiled. 
* pretty.h - character codes to readable strings. Generated by genfont
* font.c, charmap.c, translate.c - all generated by genfont too.
* catalogues.h and wp34s.op - generated by compile_cats
* xrom.c xrom_labels.h - come from the wp34s_asm
program. xrom_pre.wp34s gets generated too, but that might be a side
effect. 
* wp34s_pp.lst appears to be a text version of the compiled xrom
code. Nice to look at but not needed. 

Ok. The files that do need to be cross-compiled are those that are to
be (compiled into code to be) executed on the DM42. The files that
stay the same are those that are executed during the compilation
process, perhaps to generate other files. 

I intend to use the demoSDK calculator to get things going. USECURSES
is a problem - I can't compile the console calculator without it, and
clearly it will cause problems for DM42. So I need to see which files
have calls to curses functions in them, and do something about this. 

Files with CURSES in are:
compile_cats.c (ignore)
console.c
lcd.c
storage.c

lcd.c looks like the biggest task.
storage.c: some includes and a tmpname generator. Both gone; still compiles.
console.c: lots of printing things. I've managed to get rid of these;
it seems that the #ifdefined (USECURSES) line towards the end needed
to be moved down a line. All seems fine. Keys are read by c =
GETCHAR() which is defined in lcd.h 

lcd.c - the idea is that if USECURSES is defined, then an array of 400 dots is used to represent the LCD display.

Functions in lcd.c:
* dispreg - prints the registers on the screen. Kill this.
* set_dot, clr_dot, is_dot - obvious meanings; keep.
* setuptty - sets up the terminal. A setup command is needed, but this
has to be changed. erase() in this function is a CURSES command, I
think. 
* show_disp - does all the work of drawing the display!. Keep, and change.
* show_flags - shows f-shift, deg, etc., but does it with
printing. This can be killed; if show_disp is done properly it isn't
needed. 
* wait_for_display is void anyway
* finish_display probably needs to be replaced with something more appropriate.
* Then there are pretty and cleanse. These are already disabled
without problems. 
* show_progtrace is also disabled.

And in lcd.h:
The only complex part is to do with curses and includes. If USECURSES
is true then GETCHAR is defined as getch, PRINTF as printw, and MOVE
as move. I don't want this, as in fact I'm not using CURSES. I'm at
the stage now of either appropriating CURSES code sections or of
writing my own. I want to be able to compile the code with USECURSES
false and DM42 true. 

Nearly there, I think!

The code as it stands has four parts.
1. The code that generates other files needed for compilation.
Files thus generated are:
* charmap.c X
* consts.c. This one needs to know BigEndianness.
* font.c X
* translate.c - maps to Unicode - should work? X
* catalogues.h X
* charset7.h X
* consts.h - #include's xeq.h
* license.h
* pretty.h X
* revision.h X
* user_consts.h

2. Code that makes libraries - decnumber and consts.

3. Code and headers that don't care about USECURSES.

4. Code and headers that do.

OK. Enough waffle.
If you look at countdown/ you'll see a former Casio program converted,
first to curses and then to a working DM42 program! Problems
encountered and solved so far include:
* Printing stuff on the LCD screen, initialising, clearing,
positioning, and font choice. No actual graphics yet.
* Using sprintf with no problem!
* Reading the keyboard, one key at a time!
* Getting a menu working, with just one item - the system menu, so the
calculator can eventually be turned off.
* Getting the thing to compile despite the QSPI stuff.

The QSPI stuff is odd. QSPI is flash memory on the processor. The DM42
uses it. My programs don't; the SDKDemo calculator does, because it
uses the Intel libraries. .pgm files don't include the QSPI stuff, but
if the (non-zero) QSPI that the program is expecting doesn't match the
QSPI that is already there, the program won't run. Fair enough, I
suppose. How the Intel libraries know that they are in QSPI when
compiling is a mystery, but this explains the weird code segment
(after Key 777) that appears in the SDKDemo.

No obvious reason why I should end up using QSPI. So long as it's
zero, there seems to be no problem.

I might as well try graphics design as part of this program, just for
fun.

I also need to sort out the "off" button.

All done now. Back to this stuff.

1. I could have a makefile here in src/ which makes decnumber, consts,
and source (files). Both decnumber and consts need to be
cross-compiled, so this isn't quite trivial.

2. Then the overall making could be done from one folder up, as it is
with other calculator programs.

For stage 2 to matter I need to re-write those files that contain
CURSES commands. Overwhelmingly this is console.c (keyboard) and lcd.c
(drawing the screen). Neither should be hard now.

To make:
charmap.c, pretty.h, font.c, translate,c - depends on genfont.exe,
Makefile(?)
	all make by running genfont
genfont - comes from genfont.c

charset7.h - comes from running genchars7
catalogues.h and opcodes - comes from compile_cats

There's an issue here. compile_cats.c specifically includes
decnumber.c files and is compiled with -Idecnumber. I have no idea
why. the final output is definitely text.

I'm going to leave making consts.c and consts.h until the
library-building stage.

Library stage
=============

It occurs to me that libraries might get put into QSPI. The Intel
libraries are in a file with an .a suffix . So perhaps I should avoid
these.

So far as decNumber is concerned, there are two possibilities.
(i) Build them.
(ii) Copy the files across from wp43s! I note that wp43s doesn't build
them into a library either.

Building them seems to have proved possible. There is a makefile in
the wp34s/src/decNumber folder that, when run from that folder, puts
the object files into wp34s/src/Linux64/obj.

Right - the consts stuff.

compile_consts gets compiled. It does need to use decNumber code and
so I need to make sure that it links to the native decNumber object
files when it compiles. It generates consts.c, consts.h, userconsts or
something like that, and lots of .c files in Linux64/consts along with
a makefile. This makefile implicitly compiles the .c files and bundles
them into a library.

If I could replace this file with another that can live in the main
folder, that would be best.
It could look for .c files in Linux64/consts and then compile and link
them just as I've done for decNumber. No library stage would be
needed. The .o files would then need to be copied to obj.

So I need to check that decNumber is still fine on the host, and then
modify the decNumber makefile to one for consts. I also could stop
compile_consts producing the superfluous makefile.

First point: the flag -ldecNum34s uses libdecNum34s.a in Linux64/obj.
If this archive is needed, it should live somewhere else.
I need to re-instate the code that builds it, re-site it, and change
the linking bits.

OK.
libdecNum34s.a is now made by MakeSource, using the standard makefile
in decNumber. Having made libdecNum34s.a it deletes the decNumber
object files. It is then necessary to run make -f Makefile_calc_obj in
the decNumber directory to make the decNumber object files for the
calculator.

Slight change: make -f Makefile_calc_obj now makes and leaves the calc
object files in decNumber/obj_DM42. I now need to edit another
makefile - the final one, I suggest - to copy these object files
across. I might try a similar approach with the consts object files.

Back to consts.
It seems to work. Do make MakeLibs in wp34s/src. This makes
compile_consts and runs it to produce consts.c, consts.h, and lots of
.c files in Linux64/consts. It then runs make in wp34s using a
Makefile called MakefileConsts to compile the .c files and then to
copy the .o files into Linux64/obj/.

The final job is to compile everything together. Before I can do this
I need at at minimum to:
* add the keyloop to console.c
* write at least some stuff for lcd.c
* add the appropriate includes in these two files
* write an appropriate makefile to finish the job.

First three parts done - I need to look more closely to see what
combination of DM42, console, and curses needs to be active.

To sum up the current makefile situation:

* In src run MakeSource. This makes pretty.h font.c charmap.c
  translate.c charset7.h revision.h catalogues.h $(OPCODES) xrom.c
  xrom_labels.h $(OBJECTDIR)/libdecNum34s.a (the clean target isn't
  quite correct yet). DOESN'T WORK AT PRESENT - NEEDS CONSTS.H. ALSO
  DOES IT MAKE NEEDED DIRECTORIES? 

* In decNumber, run make -f Makefile_calc_obj. This makes the
  decNumber objects files for the calculator in decNumber/obj_calc
  NOTHING AS YET COPIES THESE FILES ACROSS.

* In src run MakeLibs. This should copy the decNumber object files
  across to OBJS, make the const*.0 files in SYSTEM/consts, and then
  copy these files across to OBJS. Here, clean should initially delete
  all in OBJS. So it's assuming that the decNumber and consts object
  files are available. Note that this uses a makefile in wp34s/ to
  ensure easy access to dmcp and other stuff needed for compilation.

* Go up to the heights of wp34s/ and run make. This makefile shouldn't
  be too hard - it does have to link the new object files with those
  already produced, but why not?

I want DM42, CONSOLE, and USECURSES defined: I have looked at where
each occurs and added DM42-dependent conditionals. I'm ignoring all
non-console code - whether this turns out to be wise I don't
know. There may be some useful stuff in the dross.

Display refresh: I don't really have much. There is
lcd_clear_buffer();
lcd_refresh(); (use this one for now)
and various drawing commands.

NOTE: check #ifndef REALBUILD occurences - these might be things like
clipboards that we don't want.
Also, look at double spaced error messages?

The wp34s code has:
display(); - no; sets things up?
variable JustDisplayed = 0 or 1; avoids duplicate calls to display
frozen_display();
reset_disp() - clears all the dots
show_disp() - uses the dots to draw the display

I'm not sure where the dots get set for drawing the digits.
Ok - this is done in set_dig, which is called from display().

So, ignoring frozen for the moment, the order is:

display();
reset_disp();
clear LCD
show_disp(); - only called from finish_display in lcd.c
draw LCD

finish_display only seems to do anything if USECURSES is going. That's
fine; we know that the console version works. So I need to change
finish_display to a DM42 version.

Nearly there - but there are problems getting the final thing to
compile.
First - the makefile system is a mess. Needs sorting, but not a
fundamental problem.
Second - dmcp.h includes a file (stdint.h) containing a couple of type definitions that conflict
with definitions in decNumber.h and decContext.h. I've added a flag
(DM42SAFE) to the files which input both dmcp.h and decNumber stuff;
should be ok. DONE
Third - there's an error from the linker about .bss overflowing
RAM. .bss is block static storage - I can look in a map file once the
compilation is successful to see where the problem lies. STILL TO FIX
- HAVE SHRUNK THE FLASH FILE TO MAKE IT FIT. INCREASING RAM IN THE
LINKER FILE STOPS THE PROGRAM LOADING. WILL NEED TO WRITE DIRECTLY TO
FILE ON DISK.
Fourth - I need to access the calculator's file system to manage flash
memory. storage.c for the console includes routines to read, write,
and use a file that represents flash memory. Until I get this sorted,
I can't compile the program. SEE ABOVE.
Fifth - there's a gettimeofday function that needs replacing with
something else too. THIS IS PART OF A BIGGER ISSUE. I NEED TO
IMPLEMENT TICKER AND HEARTBEAT FUNCTIONS - NOT TOO HARD.

It compiles and runs. Hooray!

Problems that remain:

* Lack of ticker means that holding down a key doesn't display its
  function.

* A running program can't be stopped with R/S - may be related to the
  ticker problem.

* Junk entries in some of the catalogues plus some missing that should
  be there.

* Display layout issues - non-critical.

* Keyboard layout and how to cope with this - important, but can wait.

Catalogue fixing

Commands appear in: xeq.h, compile_consts.c, commands.c .
Running compile_consts produces an op file and catalogues.h.

catalogues.h is unreadable - 4 ten-bit entries are compressed into 5
bytes, to save flash space. Not needed on the DM42 but I don't want to
unpick it!

The contents of the catalogues are hard-coded in compile_cats. This is
readable.

xeq.h is included by compile-cats. xeq.h defines enumerations of the
functions of different kinds - for example, OP_LN appears in the
monadic enumeration. These enumerations aren't named - their purpose
must be simply to assign numbers to symbols like OP_LN.

commands.c is also included by compile_cats. It isn't compiled.

All three of xeq.h, commands.c, and compile_cats, have #if...#endif
sections. Presumably these all need to match. Let's see!

Well, they all look the same to me - at least, so far as the DM42
exclusions go. Serial commands are excluded; printing commands are
left in, but this doesn't in itself seem to have caused a problem.

The catalogues that appear in compile_cats don't appear to match those
on the actual calculator. I wonder if the defining of DM42 in the
build file didn't find its way to the compilation process? I'll add it
in the MakeSource file and try again.

This has fixed the catalogue problem! I've noticed that pauses in
programs don't work - or rather, they last for ever ... (although a
keypress does end them, and R/S does stop the program during a pause).

Pause is supposed to count down in the programmed heartbeat.
Ticker.
Keyticks.
Can't hide from these for ever!

The running-program-won't-stop problem is now fixed. It was simply
that the function is_key_pressed() is defined as a blank in
console.c. Correcting this has solved the problem.

It is possible to write into the flash memory. If I make a big
constant array (like xrom[] in xrom.c) that will get put into the
flash and I can then use the system flash-write function to write it,
and ordinary pointers to read it.

Timers.
Pause - counts down every 0.1s.
Heartbeat - key press every 0.1s
Ticker - defined in data.h. Needs to be redefined. Counts up every
0.1s.
Keyticks - time since last keypress. Again, resolution is 0.1s.
These last two done. Ticker taken from the system; Keyticks defined in
terms of different between ticks now and ticks at time of last
keypress (set in console.c).

Now I need to generate the heartbeat and to make Pause count down.

Not so straightforward, due to the clock stopping every time that we
wait for a key to be pressed. Or something. So, use the system rtc.

get_rtc_ticks() returns a 32-bit integer in "24.8" format - i.e., time
to the nearest 1/256 second. So divide by 32 gives 8 ticks per second.

So define Ticker = get_rtc_ticks().
Keyticks start when a key is pressed. So we have a variable
Keytickzero, and we work out Keyticks when wanted as Ticker -
Keytickzero.

Keytickzero can be set in console, when a key press event is detected.

This is half of it. We also need to deal with Pause and with the
heartbeat.

Another approach.

See wp43s.c. Just before sys_sleep, start the timer for 100 ms. This
then ends the sleep after this time. A heartbeat could be sent; the
pause counter could be updated. This seems better.

Heartbeat: only appears in keys.c. Used to display or to hide the
function of a held-down key. Not essential, but nice. We'll do this.

Ticker
Only seems to be used directly in the function Ticks (and in serial.c,
and in whatever uses I put it to) so can be done in a straightforward
way using the rtc ticks function. On the WP34S the ticker keeps on
ticking even if keys aren't pressed. I have the option to add
resolution, at least for the TICKS function. (WP34S resolution is 0.1s).
DONE

Keyticks: all in keys.c. Measures the time since the last
keypress. Used for search timeout in catalogue; deciding what to
display for a held-down key when a heartbeat happens.

Pause: used as a test - if non-zero, then pasued; pause ended by
assigning zero to Pause; also was_paused; Pause declared as a char in xeq.c;
set in function cmdpause; also declared extern in data.h; again used
as logical test in xeq.c.

was_pause: set from Pause in keys.c. Not interesting in its own right.

Pause could have its own timer. The initial assignment starts the
timer; tests to see if Pause is non-zero could be timer tests; pause
could be ended by stopping the timer early. Seems good.

Keyticks: when a key is pressed the value from ticker is stored. Then
keyticks is the difference between current ticks and stored ticks.

Pause has been defined in a simple way - counts down on each
heartbeat. I tried using Timer 1 but it didn't work - it seemed to
count down instantly.

Ok. Flash!
I thought that using malloc might help. malloc allocates RAM
dynamically. It hasn't worked yet.
The typedef for flash is USER_FLASH. I need this as a static
variable. I tried declaring a pointer to user_flash, and initialising
this to a malloc or calloc call. Then I could assign this,
dereferenced, to the UserFlash variable itself. Doesn't work - static
variables can only be initialised with constants, and sizeof() doesn't
count as a constant (and I'm sure that the return from malloc doesn't
either). This makes sense, if you think about it for a while.

So - I need a static pointer to the userflash type. When things are
initialise I run malloc or calloc and assign to this pointer. Then I
can de-reference this pointer to get at userflash itself. Maybe I can
define UserFlash as (*my_pointer).

Doesn't work - too much else seems to expect flash to be static, with
addresses known at compile time. So far the code has either run on the
calculator (with flash) or on computers with lots of ram.

So I'll go for the flash approach.

I need a structure 
typedef struct _flash_region {
        unsigned short crc;
        unsigned short size;
        s_opcode prog[ NUMPROG_FLASH ];
} FLASH_REGION;
like this. s_opcode is a short = int - 2 bytes.
So I can have an array of short ints - or perhaps an actual struct -
declared as a const?
In xrom.c I have
const XROM_DATA s_opcode xrom[] = { list, of, thousands }
I could have
const XROM_DATA FLASH_REGION UserFlash;
XROM_DATA probably isn't needed; it says in which section the variable
will go, but a const variable should go in flash anyway.

It seems that the writing is done with xset and xcopy. Addresses have
to be aligned with multiples of 8. I could do every transfer in
multiples of 8 - a bit slow. Alternatively:

suppose I have to transfer N bytes. First, transfer 8*int(N/8) bytes.
Then, transfer the final n (<8) bytes, padded with zeros.
Or, read the final 8-n bytes so that zero padding isn't needed.
I could do something similar at the start, so that alignment isn't
actually an issue.

So both xcopy and xset can be split in three:
* transfer of first <8 bytes;
* transfer of last <8 bytes;
* transfer multiple of 8 bytes between.

Functions in storage.c that write to flash:

reset - calls clrall and init_state; not sure if these access flash

program_flash uses memcpy; bytes transferred are multiple of 256. The
same code immediately afterwards updates a file.

flash_append assembles a buffer of 256 bytes as described above, at
least at the start. If the start isn't on a page boundary a page is
assembled from what exists already and the new data. This isn't done
at the end; I guess the clue is in the name "flash
append". program_flash is used to do the transfers. xcopy is used to
build the buffers.

flash_remove uses flash_append.

flash_backup backs up the 2k of persistent ram. It uses program_flash.

flash_restore uses xcopy back to ram, so not interesting.

load_program calls append_program - presumably writing to RAM.

load_registers uses xcopy - presumably writing to RAM.

load_sigma calls sigmaCopy - writing to RAM?

load_state - again, writes to RAM.

store_program - uses flash_append

And then there's a whole lot of file saving / loading things.

Let's leave the file things alone. Things to do ...

* Look at the PersistentRam backup memory. These two parts of flash go
  together.

* Change the relevant commands in program_flash.

* Add the save / load / restore commands to the command set - they are
  probably commented out at present.

* Expand the flash size and give it a go!

* Restore the file commands, if all is working.
I shall restore: PSTO (store_program), PRCL, SAVE, LOAD.
Remember: look at xeq.h, commands.c, compile_cats . The latter must be
recompiled and re-run.

A reminder:
MakeSource - I've added a cats target, which should just do all of the
cats stuff.
134578660= 805 81e4

No luck.

I've been reading documentation from STM. First, Flash has to be
erased (0xff) before writing to it. Bits can only be changed from 1 to
zero in the writing process. Second, erasing can only happen in units
of one page, which I think is 2k on this processor. STM32L476.
Writing is less demanding, but must be to an area that has been
erased. So to change a few bytes requires a 2k section to be read,
erased, and then all re-written.

Can I work directly with a file on disk? I need to consider
this. Writing looks ok; program_flash does this. What about reading?

File commands:
fopen
fseek
fwrite
fclose are all in program_flash.
fread exists too.
The prototype for fread is 
FRESULT f_read (FIL* fp, void* buff, UINT btr, UINT* br);/* Read data from the file */
fp is pointer to the file; buff is where the read data goes; UINT is
16-bit.

So, program_flash is done for me.
The reading things use xcopy. e.g.,
xcopy (destination, &BackupFlash.rand_s1,...)
and...
...well, it can probably be made to work. I don't think that there is
one grand change that will make it work, though; I have to look
through it all.

It would be so nice to make the flash thing work. I need to align the
variables with a 2k boundary - not a problem, as there is lots of
space. I then need to change page_size to 2k. The buffer created isn't
static, so there should be RAM for this. I need to look at the writing
code again - will it really extract and re-write a whole page?
Probably. Let's go for trying to get this going.

Program_flash ( void *destination, void *source, int count ) is called by:

* init_library: ( &UserFlash, &lib, 1 ) - lib is in RAM;

* flash_append: ( dest - offset_in_page, buffer, 1 ) - dest -
  offset_in_page is at a page boundary, so long as &UserFlash is;

* flash_append: ( dest, src, count ) - here, complete pages are being
  moved

* flash_append: ( &UserFlash, fr, 1 ) - again, fine.

* flash_backup: ( &BackupFlash, &PersistentRam, sizeof( BackupFlash )
  / PAGE_SIZE ) - ok if &BackupFlash is ok.

* ...and that's it. So long as program_flash deals with the clearing,
  and everything is aligned correctly, it should be fine.

It works! The secrets are to erase the flash beforehand and then write
an entire block, taking care to have everything aligned with page
boundaries or it really won't work.

Now, files. There's a lot of file stuff in storage.c

* program_flash - writes to either wp34s-lib.dat or
  wp34s-backup.dat. The former is a backup of user flash; the latter
  backs up Persistent Ram. There is also a state file -
  wp34s.dat. program_flash doesn't write to this.

* save_statefile (filename) writes persistent RAM to a file.

* load_statefile (filename) loads both RAM and flash from a file. No -
  it reads RAM from a statefile, backup flash from the standard backup
  file, and user flash from the library file. (If there's no backup
  file a backup is emulated - not sure I like this.)

* show_log  - ignore. To do with the assembler.

* import_textfile - imports text and assembles it; adds it to program
  memory.

* export_textfile - exports a pretty version of program memory.

I'd like to be able to import programs. If I support file access in
program_flash, save_statefile, and load_statefile, that doesn't give
me that option. I'll leave this alone for now.

So I need to get the file stuff going in program_flash,
save_statefile, and load_statefile. There's also the need either to
bind commands to do this or to make it happen automatically when
appropriate. Running save_statefile when the machine is turned off
would be sensible.

Files need to live in wp34s/

I've been rather short of notes recently. Progress has been made
despite this!

* Flash writing continues to work. I can save PersistentRam to
  BackupFlash. When turned off, both PRam, BFlash, and BLib are saved
  to disk. They are re-loaded when the machine is started from scratch
  (clearly they persist otherwise). Maybe a "load_state" command would
  be nice?

* Note that the file pointer used must be ppgm_fp, provided by
  DMCP. It can still be pointed to named files, but only one at a
  time. Not a real problem (once I realised this!).

* Also note that "Erased" is still displayed at switch-on, even though
  it isn't true.

* I have 8-character file names at present; I must try longer
  ones. I'm sure they'll work.

* Remember to write-enable the system disk before writing. Don't
  disable writing until after the file is closed - it hangs otherwise!

* With fonts, Scalex and scaley are read-only. xspc (x spacing) can be
  written to with a signed integer (negative decreases spacing). t20
  (and presumably t24) only come in one size.

* Some code in the function reset_disp was missing - I must have
  deleted it when starting the project, either by accident or without
  realising its importance. This prevented the RPN annunciator from
  being displayed correctly.


Keyboard remapping
==================

... at first sight, this looks a little complicated. You'd think that
there'd be a list like K01 does this, K02 does that, etc. To some
extent there is, but a lot depends on the actual position of the keys
too.

Let's look at the major functions in keys.c.

keycode_to_cat ( keycode, shift )

It returns a catalogue. It looks through lists of catalogues (in
static variables) for the key that has been pressed, then extracts a
catalogue according to the shift state. This wouldn't be hard to
change.

keycode_to_alpha - similar purpose. It uses keycode_to_linear to find
the place in the array with that keycode, rather than searching.

The real problem is that I can't map all of the functions easily on to
the new keyboard. Blue-shifted keys in some cases are reasonable to
guess, but not always.

Options include:

* an overlay, showing f g h shifted functions - not as messy as with
  the HP30b, but not perfect either.

* a nice helpfile saying where the keys are. Inadequate.

* displaying all four (three?) functions when a key is held down

* displaying a menu along the bottom of the screen when a blue-shifted
  key is pressed and using the top row to access these functions.

I like this last idea best. It requires / implies:

* No h-shift of keys.

* Existing catalogues remain. They probably must be on yellow-shifted
  keys: const, sums, test, and x.fcn don't have an obvious place. They
  could live (along with CAT) in Catalogue.

* Setup could put up things like help and the system menu.

I've been reading through keys.c. The changes don't look unrealistic. Let's look at what is actually involved.

* I need a space at the bottom of the screen where the menu key labels can be displayed. Easy enough.

* I'd use a dot-matrix display to keep the theme consistent, and also to be easy to print on with existing code.

* I'd separate clearing the menu from clearing the rest of the buffer - easy enough.

* A menu would involve a list of six opcodes, things like OP_MON  |
  OP_RECIP. The OP_MON says which operation table to look in to find
  the label for this opcode. "prt" prints it to a string, and there is
  code (set_status_sized) in display.c that will dottify it. This can
  then be displayed.

* A number for which menu it is would exist. This and the key number
  would be an index into an array of the opcodes stored. This number
  should be part of the calculator state. The opcode array would be in
  flash, as a static variable.

* Given an opcode, how can it be processed? There seem to be lots of
  special cases in keys.c for particular keys. Is there a general rule
  for opcode processing?

* Well, no; but all of the keys that I am assigning to the menu keys
  are keys that were on the keyboard previously. So I should be able
  simply to pass the command as a keycode to process_keycode ....?

So can I do this - a more sophisticated remap or recode or whatever -
for _every_ key, and not bother re-writing keys.c completely? This
would be less elegant, but also less error-prone.

For example, suppose I press KEY_SIN. This needs to be mapped to
f-shift + key02

* I send KEY_SIN to a remapping routine (as at present). It gets
  remapped to Key02 and the shift state is set to f. I need to get
  through the processing without displaying "f"! Or maybe this
  wouldn't matter.

* I press YELLOW. f gets displayed, but shift isn't set. I press
  KEY_SIN. This goes to remapping and this time shift is set to g, and
  key to KEY02.

* If I can make this work for the keys, then I can make it work for
  the menu keys as well. There would still be work, but less work.

Shifts. There is a shift state stored in State2.shifts.

I also need to be aware of alpha mode, and possibly of integer mode.

e.g., in alpha mode, key 7 is whichever key has P on it on the
WP34S. That's ok.

e.g., in int mode, if base > 10, I have to send through the keys with
the correct letters on. This should be manageable - only keys A-F are
affected, and these are in the same places.

I could first try making this work for f and g shifts.
Yellow doesn't toggle shift; it cycles it. I don't see a function for
this; I can provide one. Put it in keys and start process_keys with a
direct check for yellow. Cycle is n->f->g->n.

When another key is pressed it is changed, based on the key and the
current shift state, to a new key and a new shift state. This new key
is sent to process_keys.

So the key mapping will have to be in keys.c as well, unless I make
shift visible in console. I can do this by including data.h.

No - leave data.h out of it and use functions to access the State
structure, like with the dots.

Ok. A key is pressed. There are 46 keys defined (43 on keyboard -
extras are screenshot, sh_up, sh_down - keys together?) numbered 1 to
43. This key is sent to a remap function. cur_shift returns the
current shift state (0,1,2,3 for none,f,g,h, plus two more for alpha -
see xeq.h). I don't see the need for shift_down() in this function
(shift_down() is defined in console.c). Ah - looking at the windows
code it seems that it checks to see if a shift key is being held down,
at least in the windows gui. I can probably ignore this.

So, remap gets a key code from 1 to 43. It also has access to the
current shift state. In response it needs to give a
WP34S key code, and to set a WP34S shift state.

Right. What happens with the A-D keys?

Keep them where they are and accept that the functions are a bit
different. The code for K02 and K03 needs changing in keys.c.

const struct _ndmap {unsigned char key_34s, int shift};

static const struct _ndmap mapping_none[] = {
{0, 0},
// Top row of DM42 1--6
{K00, 0},
{K01, 0},
{K02, 0},
{K03, 0},
{K30, 2},
{K30, 0},
// Next row of DM42 7--12
{K10, 0},
{K11, 0},
{K12, 0},
{K01, 1},
{K02, 1},
{K03, 1},
// Third row of DM42 13--17
{K20, 0},
{K21, 0},
{K22, 0},
{K23, 1},
{K24, 1},
// Fourth row of DM42 18--22
{K40, 0},
{K31, 0},
{K32, 0},
{K33, 0},
{K34, 0},
// Fifth row of DM42 23--27
{K50, 0},
{K41, 0},
{K42, 0},
{K43, 0},
{K44, 0},
// Sixth row of DM42 28--32
{K13, 0},
{K51, 0},
{K52, 0},
{K53, 0},
{K54, 0},
// Last row of DM42 33--37
{K60, 0},
{K61, 0},
{K62, 0},
{K63, 0},
{K64, 0},
// Function keys, screenshot, sh_up, sh_down
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
};

static const struct _ndmap mapping_fshift{} = {
{0, 0},
// Top row of DM42 1--6
{K54, 3},
{K33, 1},
{K44, 2},
{K31, 1},
{K30, 1},
{K30, 3},
// Next row of DM42 7--12
{K05, 0},
{K54, 1},
{K23, 3},
{K01, 2},
{K02, 2},
{K03, 2},
// Third row of DM42 13--17
{K20, 1},
{K11, 0}, //lastX not available; it's RCL L; so just RCL for now;
{K05, 3},
{0, 0}, //DISP - will be a menu
{0, 0}, //CLR - will be a menu 
// Fourth row of DM42 18--22
{K40, 0}, //BST - same as up-arrow?
{K52, 1},
{K52, 2},
{K44, 3},
{K42, 3},
// Fifth row of DM42 23--27
{K50, 0}, //SST - same as down-arrow?
{0, 0}, //BASE - will be a menu 
{K04, 3},
{K51, 3},
{K41, 3},
// Sixth row of DM42 28--32
{K14, 0},
{0, 0}, //Assign - no function
{0, 0}, //Custom - no function
{K52, 3},
{0, 0}, //Print - no function
// Last row of DM42 33--37
{K60, 3}, //off
{0, 0}, //setup - something special
{K21, 1},
{K63, 3},
{K10, 3},
// Function keys, screenshot, sh_up, sh_down
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
};

static const struct _ndmap mapping_gshift{} = {
{0, 0},
// Top row of DM42 1--6
{K64, 3}, //map first four keys back to unshifted functions
{K34, 1},
{K44, 1},
{K31, 2},
{0, 0},
{0, 0},
// Next row of DM42 7--12
{0, 0},
{K11, 3},
{K23, 3},
{0, 0},
{0, 0},
{0, 0},
// Third row of DM42 13--17
{0, 0},
{0, 0}, //menu
{0, 0}, //menu
{0, 0}, //menu
{0, 0}, 
// Fourth row of DM42 18--22
{0, 0}, 
{0, 0},
{0, 0}, //menu
{K43, 3},
{0, 0}, //menu
// Fifth row of DM42 23--27
{0, 0}, 
{0, 0}, //menu
{K20, 3},
{0, 0}, //menu
{0, 0}, //menu
// Sixth row of DM42 28--32
{K14, 2},
{0, 0}, //Assign - no function
{0, 0}, //Custom - no function
{K53, 3},
{0, 0}, //Print - no function
// Last row of DM42 33--37
{K60, 0}, 
{0, 0}, 
{0, 0},
{0, 0}, //menu
{0, 0}, //menu
// Function keys, screenshot, sh_up, sh_down
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
};

remap (int c) {
switch (cur_shift()) {

case SHIFT_N:
new_shift = mapping_none[c].shift;
new_key = mapping_none[c].key34s;
break;
case SHIFT_F:
new_shift = mapping_fshift[c].shift;
new_key = mapping_fshift[c].key34s;
break;
case SHIFT_G:
new_shift = mapping_gshift[c].shift;
new_key = mapping_gshift[c].key34s;
break;
default:
new_shift = cur_shift();
new_key = c;}

set_shift ( (enum shifts) new_shift );
if (!new_key) return new_key;
if (c==0) return 0;
if (c==KEY_F6) {
    SET_ST(STAT_MENU);
    handle_menu(&MID_MENU, MENU_RESET, 0); // App menu
    CLR_ST(STAT_MENU);
    return K_UNKNOWN;
    }
return K_UNKNOWN;

This works ok! RCL L not sorted yet, but once alpha keys are done it
should be fine.

What about alpha? I must map the letters to the actual letters on the
keyboard. There are several alpha modes:

* ordinary alpha shift

* lowercase alpha

* For each of these, normal, f, g, and h shifts.

Variables include:

* State2.alphas - alpha has been pressed; alpha mode.

* State2.alphashift - lower-case letters; shift-EXIT has been pressed.

static int keycode_to_alpha maps "from key position to alpha in the
four key planes plus the two lower-case planes". These are:

* upper; upper-f; upper-g; upper-h; lower; g-lower

So not too bad! I need to look at keycode_to_alpha and also
process_alpha.

In process() catalogues are checked for before alpha handling. The two
sets of keys needed are perhaps different...

It's more complicated still. There are keys on the DM42 that don't map
to any alpha keys on the WP34S - e.g., ':'.

We can identify characters from their codes by looking in
font.inc. 0257, for example, is indeed pi. These numbers aren't the
same as the character codes in the WP34S manual, but they are what
keycode_to_alpha uses.

So. I can now translate alpha key presses on the DM42 to alpha key
presses on the WP34S.

* First, a table in keytran.c converts DM42 key presses to WP34S key
  labels - K00, K01, etc., without regard to function and only with
  regard to keyboard position. [check - definitions of f, g, h?]

* Next, a table in keycode_to_alpha takes each WP34S key and returns
  an alpha character - either a character or an octal code. The code
  returned depends upon the shift state. This is determined by fgh and
  by whether alpha lower-shift is selected. From here on I'm hoping it
  will work. I have changed K_CMPLX and K_ARROW to K05 and K04 in the
  catalogue function; I don't know whether this is necessary or not.

* I'm hoping that after this everything will "just work". Of course, I
  need to look at alpha mode when deciding which table in keytran.c to
  use.

The keycodes (K00, etc.,) have gaps in their numbering.
0, 1, 2, 3, 4, 5,
6, 7, 8, 9, 10, 11,
12, 13, 14, 15, 16,
18, 19, 20, 21, 22,
24, 25, 26, 27, 28,
30, 31, 32, 33, 34,
36, 37, 38, 39, 40.

The gaps are at the end of the five-key rows. This means that each row
starts with a multiple of six and goes up by one for each key to the
right. This is nice.

keycode_to_linear takes a keycode and returns a linear listing, with
no gaps. The "built-in" version is nasty to keys 9, 10, 11, putting
them all at the end of the list. I may or may not want this. For the
alpha lookup I clearly don't. I need to look at the limited number of
places in which keycode_to_linear is actually used.

keycode_to_alpha - use a version including 9, 10, 11. I'm not sure
whether yellow shift should be excluded from the map. It's easy to
remove if needed.

int lc = keycode_to_linear in process_normal, process_fg_shifted,
process_h_shifted, process_cmplx. In each of these cases "lc" is used
as an index into a table of functions. It is probable that these
should not change. I have not rewritten these tables in the way that
the alpha table has been rewritten.

keycode_to_digit_or_register, like keycode_to_alpha, needs the whole
keyboard. Ideally the alpha translation table would be used for this.

It is called by: process_gtodot; process_arg; process_test;
process_status; process_labellist; process_registerlist

The two-digit local labels need to be assigned to sensible places on
the DM42 keyboard, or scrapped altogether.

process_gtodot: K40 and K50 in the code need changing, but otherwise
ok.

process_arg: this has K40, K50, and K01 in it in a sigfig mode only
section.
It also has K_F, K_ARROW, K_CMPLX, K63, ...
This is complicated. STO (etc.) can take X, Y, Z, T as arguments. On
the WP34s this aren't on numeric keys; here they are, so I'll have to
use shift to get them. Some recoding needed here. I really need to do
this in terms of the actual DM42 keys.

process_test: again, ok for corrected keycode_to_digit_or_register.
process_status: ok, again with K40 and K50.

Process_labellist - ok
Process_registerlist has a K21 in it which should be from a DM42 menu,
not the actual x<>y key itself. Not quite sure what this should do -
nothing on my WP34S, so perhaps ignore it?

What a muddle! The 34S functionality is tightly tied to its actual
keyboard layout. What to do?

At present, pressing a key in a non-alpha mode returns a different but
appropriate keycode and shift state for that key.
Pressing a key in alpha mode returns that actual keycode, but coded to
display text appropriate to the DM42.

e.g., press K23 - returns K01 shift-f
Press K23 in alpha - returns K23.

This is fine for doing calculations and for entering alpha text and
accessing catalogues. Some functions are harder to enter - e.g., STO T
- the STO key followed by T.

All of these special cases are to do with arguments. By editing the
argument code (and presenting that code with honest keypresses) I
should be mostly all right.

First, let's get alpha fully working. Shifts!
  
Because the shift keys come before the call to process_alpha in
process(), keys K_F, K_G, K_H never get interpreted as alpha but as
shifts.

Ok. If I want f-shift, return key=0, state-f-shift? If this works,
then I can skip out the shift handlers in process() when in alpha
mode.

Getting a bit messy. I can set the shift state automatically. But on
key release, there is no key to execute and I get an error.

How about sending K50 (shift key) instead of K_UNKNOWN? Then a flag
could be set to watch out for the next key_release and then stop it.

I want the shift key to work, and I want it to work in basically the
same way in alpha and non-alpha modes. I can't use K13, 14, 15 in
alpha mode. So it makes sense not to use them in normal mode either.

I've redefined K_F etc. as numbers outside the normal range. All seems
to work well now - nearly! The R/S key doesn't do its alpha
job. Probably it shouldn't? It does if unshifted, but not if
shifted. This matches normal WP34S behaviour.

More testing needed. Seems sound.

Ok. Menus!

I expect to have arrow and complex keys at the right of each menu.
I could have shifted keys 5 and 6 always being these.

Ok. Each menu has a number. Pressing a key that brings up a menu
stores this number somewhere. There is a table for each menu that
stores 34s key and shift state for each key. Pressing each key just
does this. In alpha mode, each key doesn't do anything.

Initially the menu can be displayed as a text string. It won't be
cleared each time the display is cleared.

One thought - a key could contain a whole string of key presses,
perhaps allowing access to menu items (although the starting state of
the calculator could mess this up).

Font - 400 pixels, 6 labels needed. Arrow and CPX could be smaller as
they are pretty much fixed?
If not: gap of 3 pixels between each one: 400 - 64 * 6 = 16, so that
works.
Each character is at most 5 pixels. With 1 for space and 2 pixels per
pixel in the x-direction, that gives (64/(2*6))=5.3 characters - 5
guaranteed, 6 if some are narrow. "a b/c" instead of "PRPFRC" is
sensible and fits better. This should work.
So: big dot array of string of 200 x 12 dots. A lot - 2400 bytes,
which won't fit as a static variable. 2400/8 is better.
2 lots of 200 bytes, with 6 dots per byte would work even though not
100% efficient.

General idea now:
* a menu selection key is pressed (e.g., shift-clear). This has to
return a special keycode that can be intercepted by my code, as there
is no menu-selection feature in the calculator at present.

* For example, return K_NEWMENU and a shift code that is the menu number.

* This is intercepted in the key processing routine in keys.c. It
  needs to: (a) set the current menu number; (b) clear the menu
  region, and draw the new menu; (c) there is no (c), I don't think.

In the key reading section, if a menu key is pressed it needs to be
processed separately. It returns the keycode and shift state from the
Menus matrix.

Menus are starting to work now. Need to add code for the "shift" row.

Also, reselecting a menu clears it.
Shift+up and shift+down cycle through menus.

Here's process_normal:
	case K00:
	case K01:
		if (UState.intm)
			op = OP_SPEC | (OP_A + lc);
	case K02:
	case K03:
		if (intltr(lc + 10)) {
			op = OP_SPEC | (OP_A + lc);
			return op;
		}
		return check_f_key(lc, op);
		
The intention is that in intmode, K00 and K01 cannot have their normal
function. K02 and K03 can and are only converted to letters if the
base is high enough.

This doesn't work at all on the DM42. Well, K00 and K01 are
fine. Pressing "C" gives a "D" in hex; pressing D, E, or F give
nothing.

What I want:
K00 is fine. Always to OP_SPEC | OP_A - if binaray, for example, gives
Bad Digit error.

K01, shifted, is power. Should be ok. Yes, it works.
In int mode, OP_SPEC | OP_A.


Pressing "K02" returns K03 unshifted. This needs to be OP_C if intm
and needed in that base, or square root if not.

Pressing "K03" and "K04" return g-shifted keys. Look at them
separately.

Pressing "K06" returns K03, unshifted. OP_F if base 16, XEQ otherwise.

This is ok now.

Problem: entering stack registers for arguments. On the WP34S X, y, z,
t, are all on non-numeric keys. On the DM42 they are all numeric. I
need to make the rule that after pressing ENTER, these numeric keys
return the register rather than the number on them. The code is
getting a little messy, but this can't be helped.

The keycodes now go up to 45 (excluding function keys) instead of
40. keycode_to_linear alpha needs to take this into account. Also,
keycode_to_linear is called by process_arg, normal, fg, h, complex. We
need to look at this too - f,g,h, won't be passed to anything, but
arrow and complex can be. The output of keycode to linear (lc) is used
as an index into the op_map.

I think I'll call a halt on this approach. Now that I've been forced
to master the arcane code I am better placed to simply re-write
keys.c, keys.h, and remap in console.c.

Keys go from 1 to 37. Then f-keys from 38 to 43, plus odds from 44 to
46.
KEY_DOUBLE_RELEASE is 99 - I don't know what this is - two keys held
down? So maybe heartbeat needs to change.
These keys can stay as they are - I'll use their existing key names
and codes. No gaps; keycode_to_linear is trivial.

Note that there is no K_ARROW or K_CMPLX. K_ARROW can be addressed
later; K_CMPLX can be shifted K_STO for now.

Hearbeat -> 98; K_RELEASE -> 0.

I've removed the xrom stuff from console. It still compiles!
process_keycode DONE

Actually, I'm going to go back to the old approach and think about it
carefully.
I'm sure that I can get it right with a little thought.

The WP34S reads keys, keycode c. The command c = process(c) is
executed. This calls other process functions - confirm, arg, gtodot,
hyp, test, status, (shift keys handled directly), arrow, code for
catalogues, multi, labellist, registerlist, alpha, cmplx, or - if all
else fails - fg_shifted, h_shifted, or normal.

Let's start with the last three. These use the keycode as an index
into a list of opcodes, to find out what each key does. To get this
index keycode_to_linear is called. So any key that might reach these
three handlers must return a sensible index from keycode_to_linear. At
present, this doesn't happen.

The keycodes are K00 to K64, plus K_F, K_G, K_H, K_ARROW, K_CMPLX,
K_HEARTBEAT, K_UNKNOWN. The latter throws an exception - fair enough.

I don't think that K_HEARTBEAT can get through. F, G, H are handled
explicitly - although not until after confirm, rarg, gtodot, hyp,
test, and status are called. So those need checking.

There's also the issue behind my introduction of
keycode_to_linear_for_alpha. In alpha mode (which includes many modes
listed above) the remap function simply returns keycodes corresponding
to the key pressed, rather than remapped to a WP34S key. The reason is
that there is no single WP34S key that will do - for example, on the
WP34S "times" and "T" are on the same key, and so STOx and STO.T can
be handled in the same case statement. This isn't true on the DM42, so
quite a lot of code needs to be re-written.

When is each used? keycode_to_linear is used for normal, fg- and
h-shifted functions. keycode_to_linear_for_alpha is used in the
handlers that are called when keyboard input - arguments, for example
- is relevant, rather than the functions on those keys.

Arrow is tricky. There isn't an arrow key on the DM42 - it's going to
come from one of the menu keys. CMPLX is on the keyboard, but having a
separate key might be good. I can return K04 when Arrow is pressed for
normal, etc., to get its usual function, so K_ARROW should be treated
as K_04 so far as keycode_to_linear is concerned. For the alpha map it
can stay as K_ARROW; it should be ignored, somehow.

The same applies to K_CMPLX. At present, shifted-STO is returning
K_CMPLX and it seems to work for functions. Why is this?

Because CMPLX causes process_complex to be called; it isn't looked up
itself? No - it gets passed to process_normal and does get looked up,
although what is found isn't acted upon. This needs fixing.

K_UNKNOWN seems to be triggering sigma+! Need to fix this somehow.
I've defined K_NOP which points at the same NOPpish place as the other
post-keyboard keys. I've also changed "unknown" to "nop" in menu.h and console.c.

Seems ok.

Right. ARROW! When pressed normally, it should provide the chance to
convert either DEG/RAD/GRAD or to bases 2/8/10/16.

At present, pressing arrow checks for a bad command line; sets lift;
sets State2.arrow = 1 and also SHIFT_G. The nex key gets sent to
process_arrow.

This resets state2.arrow; resets the shift; checks for DEG, RAD, GRAD;
checks for 2/8, 10/16. If not, state_unfinished.

For me, I press a menu key. That returns K_ARROW. Checking for the bad
command line is ok, but we need a new menu - 2 8 10 16 and D R G 2HMS
HMS2. This should be called up by pressing arrow. Ideally, we should
then return to the previous menu - we can leave this for now.

Given this, it looks as though process_arrow is fine.

Current bugs:

* menu keys that return K00 (in shifted states) don't work. Actually,
  the top-left key doesn't work. FIXED - I'd defined K_release as 0. Duh!

* fix (etc.) don't allow 1, 2, 3, 4 as numeric arguments. These needs
  special wiring - the problem is that the numbers co-incide with x,
  y, z, t. process_test also needs attention; process_status;
  process_labellist;
  process_registerlist; process_gtodot.
  Still working on this. ARROW_KEY is needed - I think that the
  standard mapping doesn't work. Menus in alpha mode are a more
  general issue - the keys may have unwanted effects.
  No - it turns out to be simple to fix. At present, in (generalised)
  alpha mode the mapping_alpha map is automatically applied, to menu
  keys as well. I've arranged that F5 returns K_ARROW in this mode;
  other function keys already return K_NOP.
  I won't say "fixed" - there are a lot of special cases to check -
  but it looks good.
  Tests are an issue - 0 and 1 get treated specially.
  Tests almost works - pressing 2, 3, 4, enters the register- ENTER
  allows numbers - but pressing 1 enters X, which isn't good. Pressing
  0 works.

* Now K40 and K50 aren't working! FIXED - a K50 had become a K_DOWN (K40).

* Some letters didn't work when entering labels - adding State2.multi
  to the alpha mode test fixed this.

* Also keycode_to_row_column. This, and its inverse, actually look ok.

* Now: goto__ doesn't work. e.g., typing goto 0 1 gives goto 62! Same
  with label, obvs. Label 89 does work; something to do with the keys
  1234 and their dual roles? I think it's the shorthand test - the
  n>9. I can probably fix it by putting in no_short. Yes

* Note that menu keys pressed seem to trigger shortcut mode. Look into
  this (F1 gave 85 - probably not wanted).

* Also check why the shift-0 alpha menu doesn't work (the others do).

* Also also - thicker arrow symbol for F5? Easy enough - work out the
  numbers and type them in.

Bigger things - printing, and loading assembled program files seems
sensible. Also - 4k RAM? There is actually room for another 2k ....

Pressing and releasing shift with up, down, and disp was causing a bad
digit error. At the release of the second key the calculator was
returning a keycode of 99 (KEY_DOUBLE_RELEASE) which was being looked
up well beyond the end of any of the mapping arrays. This is now
fixed.

Shift-hold up gives the Misc menu; shift-hold down gives the last
menu; shift-hold disp gives screenshot.

Strange that the infra-red commands aren't omitted when INFRARED is
undefined. I'll change this and recompile.

Currently working on the Makefile system. We have:

* MakeSource - this makes the autogenerated files. It depends on the
  decNumber library. All of this is host-based.

* Now we can run compile_consts, and make const(various).c. No need to compile
  these yet.

* Now we are ready to compile totally. We need to make the decNumber
  object files (combined in a library), the const object files (again,
  in a library), and finally the total compilation. All of this will
  fit nicely in one file.

So it should be easy to get things down to two files, both of which
live at the top.

Ok. MakeSource does the first two things - for now, running from src.

And Make, at the top, does the rest!

Right. The assembler will compile and copy files into library files,
so direct loading isn't needed. I nust need to sort out how the
calculator loads and writes the various files, because I've
forgotten.

state file - wp34s.dat.
backup file - wp34sbup.dat
library file - wp34slib.dat

I should put hyphens in these, but I'll leave it for now.

load_statefile() is called at the start of program_main, but not after
switch-off-and-on-again. This loads the state file. It then reads the
backup file into backupflash. It then reads the library file into userflash.

save_statefile() is called in shutdown (in console.c). Only called
from xeq.c (off). This writes the state file only. It is a copy of
persistent RAM.

So - when are the backup file and library files written? Not at every
switch-off.

All writing is either in save_statefile() or in program_flash.
program_flash is called in init_library(), flash_append(),
flash_backup().
init_library() appears to wipe UserFlash (?). No - only if the checksum isn't
valid. It is called at the end of load_statefile(). Fair enough.
flash_backup() copies persistent ram to backupflash. In doing this,
the backup file is updated.
flash_append is called when a program is saved to flash - PSTO or
something like that. It does append flash, but it seems to overwrite
the existing file (CREATE_ALWAYS).

Check this. The non-DM42 code only uses create_always if the file
doesn't open. Note that "rb+" means read AND write. No - I've done it
correctly. CREATE_ALWAYS is only called if there's an error opening
the file.

However, the Userflash must match what's in the flash file. Or the
wrong bit will be overwritten. Ideally, any time that the flash file
could have changed we need to copy it in. So it needs to be read in
whenever the machine starts. Reading flash should be cheap, so we
don't really need to check for changes.

What happens if the flash file gets deleted? Then it can't be read
in. Is there a command to copy all of flash to a file? No. Don't worry
at present.

Ok. Proposal: don't bother saving state when turning off. Note that ON
+ STO probably won't work. It doesn't; SAVE does seem to work. Would
be nice to have this on a menu but as it's a command, not a key, this
isn't so easy. All that's needed is to call flash_backup, I think?

So, how does the statefile get written? Command in setup? Adding OnSto
and OnRcl has worked, so this shold be fine.

So, writing to and reading from userbackup is done with onsto and
onrcl, from the setup menu, or from the P.FN menu. Writing also writes
the backup file.

Writing the state file can be done with save_statefile, from the setup
menu. This just writes the statefile.

load_statefile(): reads the state file into persistent RAM; reads the
backup file into backupflash; reads the library file into library
flash. This shouldn't be called casually; neither backup flash nor
library flash should change.

I feel that there should be a reverse of this: supersave_statefile
which writes all three files, overwriting what is there or having
special names.

load_library by itself would be nice.

Let's make a table.

What			When
====			====
read state   		load_statefile all by hand or at startup.
write state file	save_statefile from setup menu.

write userbackup	OnSto from setup menu
read userbackup		OnRcl from setup menu

write backup file	OnSto
read backup		load_statefile ditto

read library		load_statefile by hand or startup
write library		as userflash is written

What needs changing? I don't like load_statefile reading from the
library. This should be by hand - a LdLibF command.

There should also be a SvLibF command - writing the current userflash
to a file.

So I'm aiming for:

What			When
====			====
read state file		load_statefile_state by hand or at startup.
write state file	save_statefile from setup menu.

write userbackup	OnSto from setup menu
read userbackup		OnRcl from setup menu

write backup file	OnSto
read backup		load_statefile_backup by hand only.

read library		load_statefile_lib by hand only.
write library		as userflash is written
write library		by hand

When the calculator is turned off, nothing is written by default. RAM
is maintained. If people want to leave the calculator, they can save
things first. (Normally OnSto is fine.)

Three new functions: load_statefile_state, backup, and libraryYES.
Another: save_libraryfileYES.

Have removed save_statefile from shutdown.
Have removed load_statefile from startup ? less sure here.

So - rely on flash; rely on RAM unless backed up by user. User can
save and load statefiles; they can save and load to UserBackup; that
should do? Userbackup file gets automatically written; it can be
renamed if desired.

Not obviously not working. I've noticed that the CAT command shows
programs saved to flash as being in BUP. Why???

Not an issue.

I don't seem to be able to load the library file. Initially I wasn't
opening it; then the CRC was failing because of the 0xFFFF in
unwritten flash; and it still isn't working even though the file is
opening and the CRC check is commented out.

Hang on! This can't work - the code simply tries to copy data into
userflash, which won't happen. Whoops! Didn't spot this.

I have rewritten load_statefile_library. It works, at least with a
file smaller than 2k.

load_statefile_backup has the same problem. I have applied the same
fix.

Things to do. (1) Change filenames - there are plenty longer than 8
characters already present. No spaces, though! DONE
(2) Think carefully about state saving and loading. I like the idea
that a state file is saved and loaded each time the machine is turned
off, but that this should not be the one that you can save or load
yourself.
So: wp34s_save.dat for the auto one
wp34s.dat for the save / load one
usual names for the other two.DONE

(3) Think about loading program files - if smaller than 2k, which is
likely for anything that can run in RAM, flash_append can do this
easily. Is there space for a 4k buffer? Probably. Look at flash_append
examples to understand what count and size are - count is no. of
steps, size is total size (in steps) of programs in flash.

Note: RCL doesn't seem to copy a program to RAM from the
catalogue. PRCL works. Looking at the code, in labellist they have
been excluded by me. I'll think about this; I don't see any reason for it.

Changes after the split
=======================

* Fixed a misprint in the Makefile in src.

* Deleted lots of old backup files, and unneeded files.

* shift-hold-uparrow (BST) is now last menu; shift-hold-downarrow is now MISC.

* Due to the relatively large number of file commands, the SETUP menu
  is to be split in two.
  Setup 1: system; help; OnSto; OnRcl; arrow; CPX.
  Shift:   	   	 WrtSt;	LdSt;
  Setup 2: WrtLib; LdLib;LdPrg;	;	arrow; CPX.

* We need a HELP file!

+++++++++++++++++++++++

I kept getting crashes when I increased the size of the program
loading buffer to 2 * page_size. This is bad - although the crashes go
away when I make the buffer smaller again, I still can't be sure that
they won't repeat.

Also, writing to flash probably isn't very sensible when there really
is RAM available.

I've made a new RAM section called RAM2, pointing at the second bank
of RAM. I've put UserFlash and UserBackup there; the code compiles and
loads (though since the saving and loading routines involve writing to
Flash they don't work). So let's put the main memory there too, along
with any buffers, and make the whole thing work.

I've also got .git going.

What I'm aiming for is this.

* wp34s.dat written to at each "off". Read from at each full start.

* wp34s-bup.dat written along with BackupFlash when OnSto pressed; BackupFlash read when
  OnRcl pressed. wp34s-bup.dat is read into BackupFlash at each full start.

* wp34s-lib.dat written as files are added to the library. Read from
  at each full start; checked to see if valid. If not, recreated as
  empty library on disk and in memory.

* Ability to load/save named library file.

* Ability to load/save named RAM state file.

* No need to load/save named backup file.

* Ability to load named program file into library.

* Ideally, ability to save named program file.

* Possibly - ability to save complete state in single file?

Have routines called save_lib_file, load_ram_file, etc.
Each needs a file selection screen with a different title, etc. That
can be done with a function call. They then need to do different
things. What they need from the file selection screen is really just a
file name.

So:

* save_lib_file has a file selection screen command. The callback
  simply returns the file name selected. The program then proceeds.

* No - the callback function has to return 0 or 1. So: open file; if
  this succeeds return 1 (continue with code); if not return 2 (error
  message). The global variable FPT will have been set by the file
  opening command.

storage.c structure:

* Declarations and definitions.

* crc functions.

* program code editing and clearing functions

(Line 416)

* A realbuild section.

* get_region_path( int region ) defined.

(line 505)

* DM42 program_flash / !DM42 program flash.

(l628)

* init_library; flash_append, remove, flash_backup, flash_restore,
  load_program, registers, stats, config, save program to library,
  recall program. 

(l884)

* Some GUI-only definitions / functions.

(l971)

* DM42-only: import_program, load_program_file, save_statefile,
  save_libraryfile;

(l1018)

* !DM42-only: save_statefile, filename stuff.

* DM42-only: load_statefile_state, backup, library, load_statefile;
  !DM42 - load_statefile.

(L1270)

* !DM42-only stuff.

(end)

The DM-42 stuff I actually want is:

* everything up to L884: perhaps program_flash needs some changes
  still;

* The OnSto and OnRcl routines - flash_backup, flash_restore. No change.

* save_lib_file; load_lib_file

* save_ram_file; load_ram_file;

* load_backup_file.

Each of the five programs above can take an argument: 0 means use
default filename; 1 means ask for a filename.

* load_program_file.

I've commented out save_statefile and save_library_file.
Now I'm going to kill load_statefile_state ... load_statefile and
replace with the code from temp.c.

Lots has happened! With the changes above the program wouldn't even
start without crashing. I finally worked out that my "storage" memory
block was overwriting something that it shouldn't overwrite.

To get around this I'm using calloc to allocate memory. This forces me
to have pointers to ram, backup, and library rather than actual
variables, but I've been able to work around this with minimal code
changes.

Right. Do I still need all the flash_append nonsense? The nice thing
about flash_append (which calls program_flash) is that it keeps files
and memory in sync, without the need to save. This could be undone,
ultimately simplifying the code, but it might go wrong!

One disadvantage is the need to do things in sections. flash_append
does this internally - doesn't really matter to me. A bigger problem
for me is that flash_append doesn't take a file as a source. So I have
to send stuff over in sections.

I can of course just read a file into flash, but that doesn't update
the flash file.

How about killing the file stuff in program flash and updating the
disk files at the end of a command?

I tried loading a long program file bit by bit and then writing it via
flash_append bit-by-bit. This didn't work; I forgot that I can't have
two files open. So I just use calloc to create a long buffer, fill
this with the file, and then use flash_append to do the work. Seems
ok.

I haven't changed flash_append or program_flash (although I have made
PAGE_SIZE smaller again - less chance of stack collision,
perhaps?). The only buffer in normal memory is the one in
flash_append, which seems fine.

Individual programs in flash do not have crc or size associated with
them. So if I'm writing a program out to a file, I need to make these
myself.

Check: what does report_err do? Returns a numbered error.

Have stopped trying to draw a line between numbers and menu and have
instead drawn a rectangle of depth 1. This works.

Strange oversight on my part in "keycode_to_digit_or_register". How
many more???

Fixed now. A few label changes; time to make a git save thing. Commit,
that's it!

Looking at keys.c: there are comparisons between op-codes - e.g., c >=
OP_RECV. Things like OP_RECV are enumerated in xeq.h - it is this file
in which the order matters.

Ok. I want to remove serial commands. Done - they were gone anyway!
Print commands have gone - though one remains. I see in features.h
that INCLUDE_PLOTTING is defined by default. mandelbrot is the only
file in Library that uses it; let's kill it.

Note that wp34s.op or something needs to be used along with the
assembler so that the codes are correct. Well, it's there. I need to
add in the library file along with some documentation. That can come
later. 

Got to "current_catalogue_max".

What about gtodot? Doesn't work! Fixed.

JustDisplayed doesn't seem to do anything - nothing sets it to 1
except in console mode, unless the display is frozen. Leave it alone.

display() takes quite a lot of work.
finish_display just calls show_disp, so it's what's used if e.g., only
a flag has changed. show_disp does clear the display and re-draw
everything, so this is rather a lot too.

I've done nothing dramatic. I'm assuming that display() isn't being
over-called. What I have done is to note that a lot of the time
finish_display is being called simply to toggle the state of RPN, so
I've added finish_RPN which does this only. It works; it also avoids
multiple flashes at switch-on.

By redefining Ticker and Keyticks in DM42-appropriate ways I can
remove some of the DM42 tags.

Done

Now for pauses. Normally Pause is a variable that counts down
automatically. For me, it is too! I have is_paused which isn't used;
kill it. I also have start_pause which assigns its argument to a
variable called Pause. Pause counts down with the heartbeat.

I define PAUSED as Pause, simply. It's easier to read.
I do start_pause(0) instead of Pause=0. No reason.

I've got rid of it and things seem fine.

Quite a lot of DM42 references are things like ifdef CONSOLE && !def
DM42.
I'm pretty sure that console isn't defined. It only appears in
features.h, and here it is only defined if DM42 isn't.

I've done some simplifications along these lines.

I've sorted out the startup lack of y-reg display - it was my
assignment of DispMsg="" that meant that DispMsg wasn't null, so it
got displayed instead of y.

I've fixed the lower makefile - it now ends properly. A "touch" was
needed - comment in the makefile.

Can I merge them?

Suppose I have a phony target called "source" in the top makefile.
"source" calls make in the subdirectory.
To get "source" called first, I could have
all: source wp34s.elf
as the definition of all.
To be doubly sure, I could have wp34s.elf depending on source as well.

test_checksum

* does checksum of what it is sent;

* looks at pointer it is given - if not null, makes that crc equal to
  the new checksum.

* returns 1 only if the new crc is not equal to the old crc and the
  oldcrc isn't the magic marker.

I'm having a problem with the checksum of a loaded program file not
matching the checksum of the saved file. The issue, I think, is that
(ProgEnd-ProgBegin+1) is steps, not actual size. So when I calculate
the program checksum before saving, if I'm using crc16 directly I need
to double steps.

Strangely the function checksum_program does it wrong, too. It's only
called in a section of code in display.c that is commented out with
#if 0 so this doesn't matter.

crc fixed; program still not loading! Check store_program_from_buffer.

File stuff working perfectly. The problem was that I was writing the
file not from get_current_prog(), but from get_current_prog. See the
difference?

This took me waaaaaaay too long to spot. It's another thing to look
out for, though!


I've also changed things so that process_keycode_with_shift returns
immediately if the keycode is K_NOP. This means an extra K_RELEASE
gets through but it's not a problem.
